# daily-coding-problem-rs

Daily Coding Problem solved in Rust

## Problems

* [Daily Coding Problem #1 \[Easy\]](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20This%20problem%20was%20recently%20asked%20by%20Google.%0A%2F%2F%0A%2F%2F%20Given%20a%20list%20of%20numbers%20and%20a%20number%20%60k%60%2C%20return%20whether%20any%20two%20numbers%20from%0A%2F%2F%20the%20list%20add%20up%20to%20%60k%60.%0A%2F%2F%0A%2F%2F%20For%20example%2C%20given%20%60%5B10%2C%2015%2C%203%2C%207%5D%60%20and%20%60k%60%20of%20%6017%60%2C%20return%20true%20since%0A%2F%2F%20%6010%20%2B%207%60%20is%20%6017%60.%0A%2F%2F%0A%2F%2F%20Bonus%3A%20Can%20you%20do%20this%20in%20one%20pass%3F%0A%0Ause%20std%3A%3Acollections%3A%3AHashSet%3B%0A%0Afn%20any_two_numbers_add_up_to_k(numbers%3A%20%26%5Busize%5D%2C%20k%3A%20usize)%20-%3E%20bool%20%7B%0A%20%20%20%20let%20mut%20cache%20%3D%20HashSet%3A%3Anew()%3B%0A%0A%20%20%20%20for%20number%20in%20numbers%20%7B%0A%20%20%20%20%20%20%20%20if%20cache.contains(number)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20true%3B%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20cache.insert(k%20-%20number)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20false%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20numbers%3A%20%26%5Busize%5D%20%3D%20%26%5B10%2C%2015%2C%203%2C%207%5D%3B%0A%20%20%20%20let%20k%3A%20usize%20%3D%2017%3B%0A%20%20%20%20assert_eq!(any_two_numbers_add_up_to_k(numbers%2C%20k)%2C%20true)%3B%0A%7D%0A)
* [Daily Coding Problem #2 \[Hard\]](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&code=%2F%2F%20This%20problem%20was%20asked%20by%20Uber.%0A%2F%2F%0A%2F%2F%20Given%20an%20array%20of%20integers%2C%20return%20a%20new%20array%20such%20that%20each%20element%20at%0A%2F%2F%20index%20%60i%60%20of%20the%20new%20array%20is%20the%20product%20of%20all%20the%20numbers%20in%20the%20original%0A%2F%2F%20array%20except%20the%20one%20at%20%60i%60.%0A%2F%2F%0A%2F%2F%20For%20example%2C%20if%20our%20input%20was%20%60%5B1%2C%202%2C%203%2C%204%2C%205%5D%60%2C%20the%20expected%20output%20would%20be%0A%2F%2F%20%60%5B120%2C%2060%2C%2040%2C%2030%2C%2024%5D%60.%20If%20our%20input%20was%20%60%5B3%2C%202%2C%201%5D%60%2C%20the%20expected%20output%0A%2F%2F%20would%20be%20%60%5B2%2C%203%2C%206%5D%60.%0A%2F%2F%0A%2F%2F%20Follow-up%3A%20what%20if%20you%20can%27t%20use%20division%3F%0A%0A%23!%5Bfeature(min_const_generics)%5D%0A%0Afn%20array_of_product_of_numbers_excluding_i%3Cconst%20T%3A%20usize%3E(numbers%3A%20%26%5Busize%3B%20T%5D)%20-%3E%20%5Busize%3B%20T%5D%20%7B%0A%20%20%20%20let%20left%20%3D%20numbers%0A%20%20%20%20%20%20%20%20.iter()%0A%20%20%20%20%20%20%20%20.rev()%0A%20%20%20%20%20%20%20%20.enumerate()%0A%20%20%20%20%20%20%20%20.fold((%5B0%3B%20T%5D%2C%201)%2C%20%7C(mut%20acc%2C%20product)%2C%20(index%2C%20i)%7C%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20new_product%20%3D%20product%20*%20i%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20acc%5BT%20-%201%20-%20index%5D%20%3D%20new_product%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20(acc%2C%20new_product)%0A%20%20%20%20%20%20%20%20%7D)%0A%20%20%20%20%20%20%20%20.0%3B%0A%0A%20%20%20%20let%20right%20%3D%20numbers%0A%20%20%20%20%20%20%20%20.iter()%0A%20%20%20%20%20%20%20%20.enumerate()%0A%20%20%20%20%20%20%20%20.fold((%5B0%3B%20T%5D%2C%201)%2C%20%7C(mut%20acc%2C%20product)%2C%20(index%2C%20i)%7C%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20new_product%20%3D%20product%20*%20i%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20acc%5Bindex%5D%20%3D%20new_product%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20(acc%2C%20new_product)%0A%20%20%20%20%20%20%20%20%7D)%0A%20%20%20%20%20%20%20%20.0%3B%0A%0A%20%20%20%20let%20array_of_product_of_numbers_excluding_i%20%3D%0A%20%20%20%20%20%20%20%20numbers%0A%20%20%20%20%20%20%20%20%20%20%20%20.iter()%0A%20%20%20%20%20%20%20%20%20%20%20%20.enumerate()%0A%20%20%20%20%20%20%20%20%20%20%20%20.fold(%5B0%3B%20T%5D%2C%20%7Cmut%20acc%2C%20(index%2C%20_i)%7C%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20left_index%20%3D%20(index%20as%20isize)%20-%201%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20right_index%20%3D%20index%20%2B%201%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20left_product%20%3D%20if%20left_index%20%3C%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%261%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20right.get(left_index%20as%20usize).unwrap_or(%261)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20right_product%20%3D%20left.get(right_index).unwrap_or(%261)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20acc%5Bindex%5D%20%3D%20left_product%20*%20right_product%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20acc%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D)%3B%0A%0A%20%20%20%20array_of_product_of_numbers_excluding_i%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20test_1%3A%20%26%5Busize%3B%205%5D%20%3D%20%26%5B1%2C%202%2C%203%2C%204%2C%205%5D%3B%0A%20%20%20%20let%20test_2%3A%20%26%5Busize%3B%203%5D%20%3D%20%26%5B3%2C%202%2C%201%5D%3B%0A%0A%20%20%20%20assert_eq!(%0A%20%20%20%20%20%20%20%20array_of_product_of_numbers_excluding_i(test_1)%2C%0A%20%20%20%20%20%20%20%20%5B120%2C%2060%2C%2040%2C%2030%2C%2024%5D%0A%20%20%20%20)%3B%0A%20%20%20%20assert_eq!(array_of_product_of_numbers_excluding_i(test_2)%2C%20%5B2%2C%203%2C%206%5D)%3B%0A%7D%0A)
* [Daily Coding Problem #3 \[Medium\]](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=e3e6b59521fec0efb3af6e6adac13750)
* [Daily Coding Problem #4 \[Hard\]](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20This%20problem%20was%20asked%20by%20Stripe.%0A%2F%2F%0A%2F%2F%20Given%20an%20array%20of%20integers%2C%20find%20the%20first%20missing%20positive%20integer%20in%20linear%0A%2F%2F%20time%20and%20constant%20space.%20In%20other%20words%2C%20find%20the%20lowest%20positive%20integer%0A%2F%2F%20that%20does%20not%20exist%20in%20the%20array.%20The%20array%20can%20contain%20duplicates%20and%0A%2F%2F%20negative%20numbers%20as%20well.%0A%2F%2F%0A%2F%2F%20For%20example%2C%20the%20input%20%60%5B3%2C%204%2C%20-1%2C%201%5D%60%20should%20give%20%602%60.%20The%20input%20%60%5B1%2C%202%2C%200%5D%60%0A%2F%2F%20should%20give%20%603%60.%0A%2F%2F%0A%2F%2F%20You%20can%20modify%20the%20input%20array%20in-place.%0A%0Afn%20first_missing_positive_integer(numbers%3A%20%26mut%20%5Bisize%5D)%20-%3E%20usize%20%7B%0A%20%20%20%20let%20target%20%3D%201..%3D(numbers.len()%20as%20isize)%3B%0A%0A%20%20%20%20for%20i%20in%200..numbers.len()%20%7B%0A%20%20%20%20%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20number%20%3D%20numbers%5Bi%5D%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20correct_index%20%3D%20(number%20-%201)%20as%20usize%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20number%20is%20not%20within%20the%20target%20range%20and%20is%20ignored%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20!target.contains(%26number)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20number%20is%20already%20in%20the%20correct%20place%20according%20to%20the%20target%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20or%20is%20a%20duplicate%20number%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7C%7C%20numbers%5Bcorrect_index%5D%20%3D%3D%20number%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20swap%20the%20value%20at%20the%20index%20with%20the%20correct%20index%2C%20the%20same%20as%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20the%20target%0A%20%20%20%20%20%20%20%20%20%20%20%20numbers.swap(i%2C%20correct_index)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20numbers%0A%20%20%20%20%20%20%20%20.iter()%0A%20%20%20%20%20%20%20%20.enumerate()%0A%20%20%20%20%20%20%20%20.find_map(%7C(i%2C%20number)%7C%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20target%20%3D%20i%20%2B%201%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20%26(target%20as%20isize)%20%3D%3D%20number%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20None%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(target)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D)%0A%20%20%20%20%20%20%20%20.unwrap_or_else(%7C%7C%20numbers.len()%20%2B%201)%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20assert_eq!(first_missing_positive_integer(%26mut%20%5B3%2C%204%2C%20-1%2C%201%5D)%2C%202)%3B%0A%20%20%20%20assert_eq!(first_missing_positive_integer(%26mut%20%5B1%2C%202%2C%200%5D)%2C%203)%3B%0A%7D%0A)
