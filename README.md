# daily-coding-problem-rs

Daily Coding Problem solved in Rust

## Problems

* [Daily Coding Problem #1 \[Easy\]](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20This%20problem%20was%20recently%20asked%20by%20Google.%0A%2F%2F%0A%2F%2F%20Given%20a%20list%20of%20numbers%20and%20a%20number%20%60k%60%2C%20return%20whether%20any%20two%20numbers%20from%0A%2F%2F%20the%20list%20add%20up%20to%20%60k%60.%0A%2F%2F%0A%2F%2F%20For%20example%2C%20given%20%60%5B10%2C%2015%2C%203%2C%207%5D%60%20and%20%60k%60%20of%20%6017%60%2C%20return%20true%20since%0A%2F%2F%20%6010%20%2B%207%60%20is%20%6017%60.%0A%2F%2F%0A%2F%2F%20Bonus%3A%20Can%20you%20do%20this%20in%20one%20pass%3F%0A%0Ause%20std%3A%3Acollections%3A%3AHashSet%3B%0A%0Afn%20any_two_numbers_add_up_to_k(numbers%3A%20%26%5Busize%5D%2C%20k%3A%20usize)%20-%3E%20bool%20%7B%0A%20%20%20%20let%20mut%20cache%20%3D%20HashSet%3A%3Anew()%3B%0A%0A%20%20%20%20for%20number%20in%20numbers%20%7B%0A%20%20%20%20%20%20%20%20if%20cache.contains(number)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20return%20true%3B%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20cache.insert(k%20-%20number)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20false%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20numbers%3A%20%26%5Busize%5D%20%3D%20%26%5B10%2C%2015%2C%203%2C%207%5D%3B%0A%20%20%20%20let%20k%3A%20usize%20%3D%2017%3B%0A%20%20%20%20assert_eq!(any_two_numbers_add_up_to_k(numbers%2C%20k)%2C%20true)%3B%0A%7D%0A)
* [Daily Coding Problem #2 \[Hard\]](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&code=%2F%2F%20This%20problem%20was%20asked%20by%20Uber.%0A%2F%2F%0A%2F%2F%20Given%20an%20array%20of%20integers%2C%20return%20a%20new%20array%20such%20that%20each%20element%20at%0A%2F%2F%20index%20%60i%60%20of%20the%20new%20array%20is%20the%20product%20of%20all%20the%20numbers%20in%20the%20original%0A%2F%2F%20array%20except%20the%20one%20at%20%60i%60.%0A%2F%2F%0A%2F%2F%20For%20example%2C%20if%20our%20input%20was%20%60%5B1%2C%202%2C%203%2C%204%2C%205%5D%60%2C%20the%20expected%20output%20would%20be%0A%2F%2F%20%60%5B120%2C%2060%2C%2040%2C%2030%2C%2024%5D%60.%20If%20our%20input%20was%20%60%5B3%2C%202%2C%201%5D%60%2C%20the%20expected%20output%0A%2F%2F%20would%20be%20%60%5B2%2C%203%2C%206%5D%60.%0A%2F%2F%0A%2F%2F%20Follow-up%3A%20what%20if%20you%20can%27t%20use%20division%3F%0A%0A%23!%5Bfeature(min_const_generics)%5D%0A%0Afn%20array_of_product_of_numbers_excluding_i%3Cconst%20T%3A%20usize%3E(numbers%3A%20%26%5Busize%3B%20T%5D)%20-%3E%20%5Busize%3B%20T%5D%20%7B%0A%20%20%20%20let%20left%20%3D%20numbers%0A%20%20%20%20%20%20%20%20.iter()%0A%20%20%20%20%20%20%20%20.rev()%0A%20%20%20%20%20%20%20%20.enumerate()%0A%20%20%20%20%20%20%20%20.fold((%5B0%3B%20T%5D%2C%201)%2C%20%7C(mut%20acc%2C%20product)%2C%20(index%2C%20i)%7C%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20new_product%20%3D%20product%20*%20i%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20acc%5BT%20-%201%20-%20index%5D%20%3D%20new_product%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20(acc%2C%20new_product)%0A%20%20%20%20%20%20%20%20%7D)%0A%20%20%20%20%20%20%20%20.0%3B%0A%0A%20%20%20%20let%20right%20%3D%20numbers%0A%20%20%20%20%20%20%20%20.iter()%0A%20%20%20%20%20%20%20%20.enumerate()%0A%20%20%20%20%20%20%20%20.fold((%5B0%3B%20T%5D%2C%201)%2C%20%7C(mut%20acc%2C%20product)%2C%20(index%2C%20i)%7C%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20new_product%20%3D%20product%20*%20i%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20acc%5Bindex%5D%20%3D%20new_product%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20(acc%2C%20new_product)%0A%20%20%20%20%20%20%20%20%7D)%0A%20%20%20%20%20%20%20%20.0%3B%0A%0A%20%20%20%20let%20array_of_product_of_numbers_excluding_i%20%3D%0A%20%20%20%20%20%20%20%20numbers%0A%20%20%20%20%20%20%20%20%20%20%20%20.iter()%0A%20%20%20%20%20%20%20%20%20%20%20%20.enumerate()%0A%20%20%20%20%20%20%20%20%20%20%20%20.fold(%5B0%3B%20T%5D%2C%20%7Cmut%20acc%2C%20(index%2C%20_i)%7C%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20left_index%20%3D%20(index%20as%20isize)%20-%201%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20right_index%20%3D%20index%20%2B%201%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20left_product%20%3D%20if%20left_index%20%3C%200%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%261%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20right.get(left_index%20as%20usize).unwrap_or(%261)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20let%20right_product%20%3D%20left.get(right_index).unwrap_or(%261)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20acc%5Bindex%5D%20%3D%20left_product%20*%20right_product%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20acc%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D)%3B%0A%0A%20%20%20%20array_of_product_of_numbers_excluding_i%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20test_1%3A%20%26%5Busize%3B%205%5D%20%3D%20%26%5B1%2C%202%2C%203%2C%204%2C%205%5D%3B%0A%20%20%20%20let%20test_2%3A%20%26%5Busize%3B%203%5D%20%3D%20%26%5B3%2C%202%2C%201%5D%3B%0A%0A%20%20%20%20assert_eq!(%0A%20%20%20%20%20%20%20%20array_of_product_of_numbers_excluding_i(test_1)%2C%0A%20%20%20%20%20%20%20%20%5B120%2C%2060%2C%2040%2C%2030%2C%2024%5D%0A%20%20%20%20)%3B%0A%20%20%20%20assert_eq!(array_of_product_of_numbers_excluding_i(test_2)%2C%20%5B2%2C%203%2C%206%5D)%3B%0A%7D%0A)
* [Daily Coding Problem #3 \[Medium\]](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&gist=e3e6b59521fec0efb3af6e6adac13750)
* [Daily Coding Problem #4 \[Hard\]](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20This%20problem%20was%20asked%20by%20Stripe.%0A%2F%2F%0A%2F%2F%20Given%20an%20array%20of%20integers%2C%20find%20the%20first%20missing%20positive%20integer%20in%20linear%0A%2F%2F%20time%20and%20constant%20space.%20In%20other%20words%2C%20find%20the%20lowest%20positive%20integer%0A%2F%2F%20that%20does%20not%20exist%20in%20the%20array.%20The%20array%20can%20contain%20duplicates%20and%0A%2F%2F%20negative%20numbers%20as%20well.%0A%2F%2F%0A%2F%2F%20For%20example%2C%20the%20input%20%60%5B3%2C%204%2C%20-1%2C%201%5D%60%20should%20give%20%602%60.%20The%20input%20%60%5B1%2C%202%2C%200%5D%60%0A%2F%2F%20should%20give%20%603%60.%0A%2F%2F%0A%2F%2F%20You%20can%20modify%20the%20input%20array%20in-place.%0A%0Afn%20first_missing_positive_integer(numbers%3A%20%26mut%20%5Bisize%5D)%20-%3E%20usize%20%7B%0A%20%20%20%20let%20target%20%3D%201..%3D(numbers.len()%20as%20isize)%3B%0A%0A%20%20%20%20for%20i%20in%200..numbers.len()%20%7B%0A%20%20%20%20%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20number%20%3D%20numbers%5Bi%5D%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20correct_index%20%3D%20(number%20-%201)%20as%20usize%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20number%20is%20not%20within%20the%20target%20range%20and%20is%20ignored%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20!target.contains(%26number)%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20number%20is%20already%20in%20the%20correct%20place%20according%20to%20the%20target%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20or%20is%20a%20duplicate%20number%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7C%7C%20numbers%5Bcorrect_index%5D%20%3D%3D%20number%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20swap%20the%20value%20at%20the%20index%20with%20the%20correct%20index%2C%20the%20same%20as%0A%20%20%20%20%20%20%20%20%20%20%20%20%2F%2F%20the%20target%0A%20%20%20%20%20%20%20%20%20%20%20%20numbers.swap(i%2C%20correct_index)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20numbers%0A%20%20%20%20%20%20%20%20.iter()%0A%20%20%20%20%20%20%20%20.enumerate()%0A%20%20%20%20%20%20%20%20.find_map(%7C(i%2C%20number)%7C%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20target%20%3D%20i%20%2B%201%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20%26(target%20as%20isize)%20%3D%3D%20number%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20None%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20Some(target)%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%7D)%0A%20%20%20%20%20%20%20%20.unwrap_or_else(%7C%7C%20numbers.len()%20%2B%201)%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20assert_eq!(first_missing_positive_integer(%26mut%20%5B3%2C%204%2C%20-1%2C%201%5D)%2C%202)%3B%0A%20%20%20%20assert_eq!(first_missing_positive_integer(%26mut%20%5B1%2C%202%2C%200%5D)%2C%203)%3B%0A%7D%0A)
* [Daily Coding Problem #5 \[Medium\]](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=%2F%2F%20This%20problem%20was%20asked%20by%20Jane%20Street.%0A%2F%2F%0A%2F%2F%20%60cons(a%2C%20b)%60%20constructs%20a%20pair%2C%20and%20%60car(pair)%60%20and%20%60cdr(pair)%60%20returns%20the%0A%2F%2F%20first%20and%20last%20element%20of%20that%20pair.%20For%20example%2C%20%60car(cons(3%2C%204))%60%20returns%0A%2F%2F%20%603%60%2C%20and%20%60cdr(cons(3%2C%204))%60%20returns%20%604%60.%0A%2F%2F%0A%2F%2F%20Given%20this%20implementation%20of%20%60cons%60%3A%0A%2F%2F%0A%2F%2F%20%60%60%60%0A%2F%2F%20def%20cons(a%2C%20b)%3A%0A%2F%2F%20%20%20%20%20def%20pair(f)%3A%0A%2F%2F%20%20%20%20%20%20%20%20%20return%20f(a%2C%20b)%0A%2F%2F%20%20%20%20%20return%20pair%0A%2F%2F%20%60%60%60%0A%2F%2F%0A%2F%2F%20Implement%20%60car%60%20and%20%60cdr%60.%0A%0Afn%20cons%3CT%3A%20Fn(usize%2C%20usize)%20-%3E%20usize%3E(a%3A%20usize%2C%20b%3A%20usize)%20-%3E%20impl%20Fn(T)%20-%3E%20usize%20%7B%0A%20%20%20%20move%20%7Cf%3A%20T%7C%20f(a%2C%20b)%0A%7D%0A%0Afn%20car(pair%3A%20%26impl%20Fn(fn(usize%2C%20usize)%20-%3E%20usize)%20-%3E%20usize)%20-%3E%20usize%20%7B%0A%20%20%20%20fn%20left(a%3A%20usize%2C%20_b%3A%20usize)%20-%3E%20usize%20%7B%0A%20%20%20%20%20%20%20%20a%0A%20%20%20%20%7D%0A%20%20%20%20pair(left)%0A%7D%0A%0Afn%20cdr(pair%3A%20%26impl%20Fn(fn(usize%2C%20usize)%20-%3E%20usize)%20-%3E%20usize)%20-%3E%20usize%20%7B%0A%20%20%20%20fn%20right(_a%3A%20usize%2C%20b%3A%20usize)%20-%3E%20usize%20%7B%0A%20%20%20%20%20%20%20%20b%0A%20%20%20%20%7D%0A%20%20%20%20pair(right)%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20pair%20%3D%20cons(3%2C%204)%3B%0A%20%20%20%20assert_eq!(car(%26pair)%2C%203)%3B%0A%20%20%20%20assert_eq!(cdr(%26pair)%2C%204)%3B%0A%7D%0A)
* [Daily Coding Problem #6 \[Hard\]](https://play.rust-lang.org/?version=stable&mode=debug&edition=2018&code=use%20std%3A%3Acollections%3A%3AHashMap%3B%0Ause%20std%3A%3Amarker%3A%3APhantomPinned%3B%0Ause%20std%3A%3Apin%3A%3APin%3B%0A%0Aconst%20EMPTY%3A%20usize%20%3D%200%3B%0A%0A%23%5Bderive(Debug)%5D%0Astruct%20XORLinkedListNode%3CT%3E%20%7B%0A%20%20%20%20element%3A%20T%2C%0A%20%20%20%20both%3A%20usize%2C%0A%20%20%20%20_pin%3A%20PhantomPinned%2C%0A%7D%0A%0Aimpl%3CT%3E%20XORLinkedListNode%3CT%3E%20%7B%0A%20%20%20%20fn%20new(element%3A%20T)%20-%3E%20Pin%3CBox%3CSelf%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20res%20%3D%20XORLinkedListNode%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20element%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20both%3A%20EMPTY%2C%0A%20%20%20%20%20%20%20%20%20%20%20%20_pin%3A%20PhantomPinned%2C%0A%20%20%20%20%20%20%20%20%7D%3B%0A%0A%20%20%20%20%20%20%20%20let%20mut%20boxed%20%3D%20Box%3A%3Apin(res)%3B%0A%0A%20%20%20%20%20%20%20%20boxed.set_both(EMPTY)%3B%0A%0A%20%20%20%20%20%20%20%20boxed%0A%20%20%20%20%7D%0A%7D%0A%0Atrait%20SetBoth%20%7B%0A%20%20%20%20fn%20set_both(%26mut%20self%2C%20prev_ptr%3A%20usize)%3B%0A%20%20%20%20fn%20get_pointer(%26self)%20-%3E%20usize%3B%0A%7D%0A%0Aimpl%3CT%3E%20SetBoth%20for%20Pin%3CBox%3CXORLinkedListNode%3CT%3E%3E%3E%20%7B%0A%20%20%20%20fn%20set_both(%26mut%20self%2C%20prev_ptr%3A%20usize)%20%7B%0A%20%20%20%20%20%20%20%20let%20node_ptr%20%3D%20self.get_pointer()%3B%0A%0A%20%20%20%20%20%20%20%20%2F%2F%20We%20need%20%60unsafe%60%20since%20we%20are%20using%20self-referential%20data%2C%20but%20we%0A%20%20%20%20%20%20%20%20%2F%2F%20know%20this%20is%20safe%20because%20modifying%20a%20field%20doesn%27t%20move%20the%20whole%0A%20%20%20%20%20%20%20%20%2F%2F%20struct%0A%20%20%20%20%20%20%20%20unsafe%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20mut_ref%20%3D%20Pin%3A%3Aas_mut(self)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20Pin%3A%3Aget_unchecked_mut(mut_ref).both%20%3D%20prev_ptr%20%5E%20node_ptr%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20get_pointer(%26self)%20-%3E%20usize%20%7B%0A%20%20%20%20%20%20%20%20self.as_ref().get_ref()%20as%20*const%20XORLinkedListNode%3CT%3E%20as%20usize%0A%20%20%20%20%7D%0A%7D%0A%0A%23%5Bderive(Debug%2C%20Default)%5D%0Astruct%20XORLinkedList%3CT%3E%20%7B%0A%20%20%20%20%2F%2F%20Using%20a%20hashmap%20to%20safely%20refer%20to%20nodes%20in%20the%20linked%20list%2C%20this%20could%0A%20%20%20%20%2F%2F%20be%20eschewed%20in%20favor%20of%20using%20%60std%3A%3Amem%3A%3Aforget%60%20and%20%60Box%3A%3Afrom_raw%60%2C%20but%0A%20%20%20%20%2F%2F%20that%20is%20%60unsafe%60%0A%20%20%20%20nodes%3A%20HashMap%3Cusize%2C%20Pin%3CBox%3CXORLinkedListNode%3CT%3E%3E%3E%3E%2C%0A%20%20%20%20head%3A%20Option%3Cusize%3E%2C%0A%7D%0A%0Aimpl%3CT%3E%20XORLinkedList%3CT%3E%20%7B%0A%20%20%20%20fn%20add(%26mut%20self%2C%20element%3A%20T)%20%7B%0A%20%20%20%20%20%20%20%20if%20let%20Some(head_ptr)%20%3D%20self.head%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20head_node%20%3D%20self.nodes.get_mut(%26head_ptr).unwrap()%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20mut%20tail_ptr%20%3D%20head_ptr%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20mut%20tail_node%20%3D%20head_node%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20loop%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20if%20tail_node.both%20%3D%3D%20tail_ptr%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20break%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20tail_ptr%20%3D%20tail_node.both%20%5E%20tail_ptr%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20tail_node%20%3D%20self.nodes.get_mut(%26tail_ptr).unwrap()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20node%20%3D%20XORLinkedListNode%3A%3Anew(element)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20node_ptr%20%3D%20node.get_pointer()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20tail_node.set_both(node_ptr)%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20self.nodes.insert(node_ptr%2C%20node)%3B%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20node%20%3D%20XORLinkedListNode%3A%3Anew(element)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20node_ptr%20%3D%20node.get_pointer()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20self.nodes.insert(node_ptr%2C%20node)%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20self.head%20%3D%20Some(node_ptr)%3B%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%0A%20%20%20%20fn%20get(%26self%2C%20index%3A%20usize)%20-%3E%20Option%3C%26XORLinkedListNode%3CT%3E%3E%20%7B%0A%20%20%20%20%20%20%20%20let%20nodes_len%20%3D%20self.nodes.len()%3B%0A%0A%20%20%20%20%20%20%20%20if%20let%20(true%2C%20Some(head_ptr))%20%3D%20(index%20%3C%20nodes_len%2C%20self.head)%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20head_node%20%3D%20self.nodes.get(%26head_ptr).unwrap()%3B%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20mut%20tail_ptr%20%3D%20head_ptr%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20let%20mut%20tail_node%20%3D%20head_node%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20for%20_%20in%200..index%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20tail_ptr%20%3D%20tail_node.both%20%5E%20tail_ptr%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20tail_node%20%3D%20self.nodes.get(%26tail_ptr).unwrap()%3B%0A%20%20%20%20%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%20%20%20%20%20%20%20%20Some(tail_node)%0A%20%20%20%20%20%20%20%20%7D%20else%20%7B%0A%20%20%20%20%20%20%20%20%20%20%20%20None%0A%20%20%20%20%20%20%20%20%7D%0A%20%20%20%20%7D%0A%7D%0A%0Afn%20main()%20%7B%0A%20%20%20%20let%20mut%20xor_linked_list_node%3A%20XORLinkedList%3C%26str%3E%20%3D%20Default%3A%3Adefault()%3B%0A%20%20%20%20xor_linked_list_node.add(%22hello%22)%3B%0A%20%20%20%20xor_linked_list_node.add(%22world%22)%3B%0A%20%20%20%20xor_linked_list_node.add(%22foo%22)%3B%0A%20%20%20%20xor_linked_list_node.add(%22bar%22)%3B%0A%0A%20%20%20%20assert_eq!(xor_linked_list_node.get(0).unwrap().element%2C%20%22hello%22)%3B%0A%20%20%20%20assert_eq!(xor_linked_list_node.get(1).unwrap().element%2C%20%22world%22)%3B%0A%20%20%20%20assert_eq!(xor_linked_list_node.get(2).unwrap().element%2C%20%22foo%22)%3B%0A%20%20%20%20assert_eq!(xor_linked_list_node.get(3).unwrap().element%2C%20%22bar%22)%3B%0A%20%20%20%20assert!(xor_linked_list_node.get(4).is_none())%3B%0A%7D%0A)
